# generated by datamodel-codegen:
#   filename:  signal-server-openapi.yaml
#   timestamp: 2025-01-27T22:02:59+00:00

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Union


@dataclass
class ServiceIdentifier:
    """
    A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
    """


@dataclass
class UsernameHashResponse:
    usernameHash: Optional[str] = None
    """
    The hash of the confirmed username, as supplied in the request
    """
    usernameLinkHandle: Optional[str] = None
    """
    A handle that can be included in username links to retrieve the stored encrypted username
    """


@dataclass
class ConfirmUsernameHashRequest:
    zkProof: str
    usernameHash: Optional[str] = None
    encryptedUsername: Optional[str] = None
    """
    The url-safe base64-encoded encrypted username to be stored for username links
    """


@dataclass
class AccountIdentifierResponse:
    uuid: str
    """
    An identifier for an account based on the account's ACI
    """


@dataclass
class EncryptedUsername:
    usernameLinkEncryptedValue: str
    """
    the URL-safe base64 encoding of the encrypted username
    """
    keepLinkHandle: Optional[bool] = None
    """
    if set and the account already has an encrypted-username link handle, reuse the same link handle rather than generating a new one. The response will still have the link handle.
    """


@dataclass
class ReserveUsernameHashResponse:
    usernameHash: Optional[str] = None


@dataclass
class ReserveUsernameHashRequest:
    usernameHashes: List[str]


class Capability(Enum):
    STORAGE = "STORAGE"
    TRANSFER = "TRANSFER"
    DELETE_SYNC = "DELETE_SYNC"
    VERSIONED_EXPIRATION_TIMER = "VERSIONED_EXPIRATION_TIMER"
    STORAGE_SERVICE_RECORD_KEY_ROTATION = "STORAGE_SERVICE_RECORD_KEY_ROTATION"


@dataclass
class AccountAttributes:
    fetchesMessages: Optional[bool] = None
    registrationId: Optional[int] = None
    name: Optional[str] = None
    registrationLock: Optional[str] = None
    unidentifiedAccessKey: Optional[str] = None
    unrestrictedUnidentifiedAccess: Optional[bool] = None
    capabilities: Optional[List[Capability]] = None
    discoverableByPhoneNumber: Optional[bool] = None
    recoveryPassword: Optional[str] = None
    eachRegistrationIdValid: Optional[bool] = None
    pniRegistrationId: Optional[int] = None


@dataclass
class ApnRegistrationId:
    """
    An APNs token set for the account's primary device. If provided, the account's primary
    device will be notified of new messages via push notifications to the given token.
    Callers must provide exactly one of an APNs token set, an FCM token, or an
    `AccountAttributes` entity with `fetchesMessages` set to `true`.

    """

    apnRegistrationId: str


@dataclass
class GcmRegistrationId:
    """
    An FCM/GCM token for the account's primary device. If provided, the account's primary
    device will be notified of new messages via push notifications to the given token.
    Callers must provide exactly one of an APNs token set, an FCM token, or an
    `AccountAttributes` entity with `fetchesMessages` set to `true`.

    """

    gcmRegistrationId: str


@dataclass
class DeviceName:
    deviceName: str


@dataclass
class RegistrationLock:
    registrationLock: str


@dataclass
class UsernameLinkHandle:
    usernameLinkHandle: str
    """
    A handle that can be included in username links to retrieve the stored encrypted username
    """


@dataclass
class BackupEntitlement:
    """
    If present, the backup level set via /v1/archives/redeem-receipt
    """

    backupLevel: Optional[int] = None
    """
    The backup level of the account
    """
    expirationSeconds: Optional[int] = None
    """
    When the backup entitlement expires, in number of seconds since epoch
    """


@dataclass
class BadgeEntitlement:
    """
    Active badges added via /v1/donation/redeem-receipt
    """

    id: Optional[str] = None
    """
    The badge id
    """
    visible: Optional[bool] = None
    """
    Whether the badge is currently configured to be visible
    """
    expirationSeconds: Optional[int] = None
    """
    When the badge expires, in number of seconds since epoch
    """


@dataclass
class Entitlements:
    """
    entitlements for this account and their current expirations
    """

    badges: Optional[List[BadgeEntitlement]] = None
    """
    Active badges added via /v1/donation/redeem-receipt
    """
    backup: Optional[BackupEntitlement] = None


@dataclass
class MismatchedDevices:
    missingDevices: Optional[List[str]] = None
    """
    Devices present on the account but absent in the request
    """
    extraDevices: Optional[List[str]] = None
    """
    Devices absent on the request but present in the account
    """


@dataclass
class StaleDevices:
    staleDevices: Optional[List[str]] = None
    """
    Devices that are no longer active
    """


@dataclass
class ExternalServiceCredentials:
    username: Optional[str] = None
    password: Optional[str] = None


@dataclass
class RegistrationLockFailure:
    """
    Information about the current Registration lock and SVR credentials. With a correct PIN, the credentials can
    be used to recover the secret used to derive the registration lock password.

    """

    timeRemaining: Optional[int] = None
    """
    Time remaining in milliseconds before the existing registration lock expires
    """
    svr2Credentials: Optional[ExternalServiceCredentials] = None
    svr3Credentials: Optional[ExternalServiceCredentials] = None


@dataclass
class ECPublicKey:
    type: Optional[int] = None
    publicKeyBytes: Optional[str] = None


@dataclass
class ECSignedPreKey:
    """
    A signed EC pre-key to be associated with this account's PNI.

    """

    keyId: Optional[int] = None
    """
    An arbitrary ID for this key, which will be provided by peers using this key to encrypt messages so the private key can be looked up.
    Should not be zero. Should be less than 2^24.

    """
    publicKey: Optional[str] = None
    """
    The public key, serialized in libsignal's elliptic-curve public key format and then base64-encoded.

    """
    signature: Optional[str] = None
    """
    The signature of the serialized `publicKey` with the account (or phone-number identity)'s identity key, base64-encoded.

    """


@dataclass
class IdentityKey:
    """
    The PNI-associated identity key for the account, encoded as a base64 string.

    """

    publicKey: Optional[ECPublicKey] = None
    fingerprint: Optional[str] = None


@dataclass
class IncomingMessage:
    type: Optional[int] = None
    destinationDeviceId: Optional[str] = None
    destinationRegistrationId: Optional[int] = None
    content: Optional[str] = None


@dataclass
class KEMSignedPreKey:
    """
    A signed Kyber-1024 "last resort" pre-key to be associated with this account's PNI.

    """

    keyId: Optional[int] = None
    """
    An arbitrary ID for this key, which will be provided by peers using this key to encrypt messages so the private key can be looked up.
    Should not be zero. Should be less than 2^24. The owner of this key must be able to determine from the key ID whether this represents
    a single-use or last-resort key, but another party should *not* be able to tell.

    """
    publicKey: Optional[str] = None
    """
    The public key, serialized in libsignal's Kyber1024 public key format and then base64-encoded.

    """
    signature: Optional[str] = None
    """
    The signature of the serialized `publicKey` with the account (or phone-number identity)'s identity key, base64-encoded.

    """


@dataclass
class PhoneNumberIdentityKeyDistributionRequest:
    pniIdentityKey: IdentityKey
    deviceMessages: List[IncomingMessage]
    """
    A list of synchronization messages to send to companion devices to supply the private keys
    associated with the new identity key and their new prekeys.
    Exactly one message must be supplied for each enabled device other than the sending (primary) device.

    """
    devicePniSignedPrekeys: Dict[str, ECSignedPreKey]
    """
    A new signed elliptic-curve prekey for each enabled device on the account, including this one.
    Each must be accompanied by a valid signature from the new identity key in this request.
    """
    pniRegistrationIds: Dict[str, int]
    """
    The new registration ID to use for the phone-number identity of each device, including this one.
    """
    devicePniPqLastResortPrekeys: Optional[Dict[str, KEMSignedPreKey]] = None
    """
    A new signed post-quantum last-resort prekey for each enabled device on the account, including this one.
    May be absent, in which case the last resort PQ prekeys for each device will be deleted if any had been stored.
    If present, must contain one prekey per enabled device including this one.
    Prekeys for devices that did not previously have any post-quantum prekeys stored will be silently dropped.
    Each must be accompanied by a valid signature from the new identity key in this request.
    """


@dataclass
class BadgeDataReport:
    id: Optional[str] = None
    expiration: Optional[str] = None
    visible: Optional[bool] = None


@dataclass
class DeviceDataReport:
    id: Optional[str] = None
    lastSeen: Optional[str] = None
    created: Optional[str] = None
    userAgent: Optional[str] = None


@dataclass
class PhoneNumberDiscoverabilityRequest:
    discoverableByPhoneNumber: bool


@dataclass
class UploadDescriptorResponse:
    cdn: Optional[int] = None
    """
    Indicates the CDN type. 3 indicates resumable uploads using TUS
    """
    key: Optional[str] = None
    """
    The location within the specified cdn where the finished upload can be found.
    """
    headers: Optional[Dict[str, str]] = None
    """
    A map of headers to include with all upload requests. Potentially contains time-limited upload credentials
    """
    signedUploadLocation: Optional[str] = None
    """
    The URL to upload to with the appropriate protocol
    """


@dataclass
class BackupInfoResponse:
    cdn: Optional[int] = None
    """
    The CDN type where the message backup is stored. Media may be stored elsewhere.
    """
    backupDir: Optional[str] = None
    """
    The base directory of your backup data on the cdn. The message backup can be found in the returned cdn at
    /backupDir/backupName and stored media can be found at /backupDir/mediaDir/mediaId

    """
    mediaDir: Optional[str] = None
    """
    The prefix path component for media objects on a cdn. Stored media for mediaId can be found at
    /backupDir/mediaDir/mediaId.

    """
    backupName: Optional[str] = None
    """
    The name of the most recent message backup on the cdn. The backup is at /backupDir/backupName
    """
    usedSpace: Optional[int] = None
    """
    The amount of space used to store media
    """


@dataclass
class Entry:
    """
    Detailed outcome information for each copy request in the batch
    """

    mediaId: str
    """
    The mediaId of the object, encoded in URL-safe padded base64
    """
    status: Optional[int] = None
    """
    The outcome of the copy attempt.
    A 200 indicates the object was successfully copied.
    A 400 indicates an invalid argument in the request
    A 410 indicates that the source object was not found
    A 413 indicates that the media quota was exhausted

    """
    failureReason: Optional[str] = None
    """
    On a copy failure, a detailed failure reason
    """
    cdn: Optional[int] = None
    """
    The backup cdn where this media object is stored
    """


@dataclass
class RemoteAttachment:
    cdn: int
    """
    The attachment cdn
    """
    key: str
    """
    The attachment key
    """


@dataclass
class CopyMediaResponse:
    cdn: int
    """
    The backup cdn where this media object is stored
    """


@dataclass
class MediaToDelete:
    cdn: int
    """
    The backup cdn where this media object is stored
    """
    mediaId: str
    """
    The mediaId of the object in URL-safe base64
    """


@dataclass
class BackupAuthCredential:
    """
    A map of credential types to lists of BackupAuthCredentials and their validity periods
    """

    credential: Optional[str] = None
    """
    A BackupAuthCredential, encoded in standard padded base64
    """
    redemptionTime: Optional[int] = None
    """
    The day on which this credential is valid. Seconds since epoch truncated to day boundary
    """


@dataclass
class BackupAuthCredentialsResponse:
    credentials: Optional[Dict[str, List[BackupAuthCredential]]] = None
    """
    A map of credential types to lists of BackupAuthCredentials and their validity periods
    """


@dataclass
class StoredMediaObject:
    """
    A page of media objects stored for this backup ID
    """

    cdn: int
    """
    The backup cdn where this media object is stored
    """
    mediaId: str
    """
    The mediaId of the object in URL-safe base64
    """
    objectLength: int
    """
    The length of the object in bytes
    """


@dataclass
class ReadAuthResponse:
    headers: Optional[Dict[str, str]] = None
    """
    Auth headers to include with cdn read requests
    """


@dataclass
class RedeemBackupReceiptRequest:
    receiptCredentialPresentation: str
    """
    Presentation of a ZK receipt encoded in standard padded base64
    """


@dataclass
class SetBackupIdRequest:
    messagesBackupAuthCredentialRequest: str
    """
    A BackupAuthCredentialRequest containing a blinded encrypted backup-id, encoded in standard padded base64.
    This backup-id should be used for message backups only, and must have the message backup type set on the
    credential.

    """
    mediaBackupAuthCredentialRequest: str
    """
    A BackupAuthCredentialRequest containing a blinded encrypted backup-id, encoded in standard padded base64.
    This backup-id should be used for media only, and must have the media type set on the credential.

    """


@dataclass
class SetPublicKeyRequest:
    publicKey: Optional[str] = None
    """
    The public key, serialized in libsignal's elliptic-curve public key format and then encoded as a standard (i.e.
    not URL-safe), padded, base64-encoded string.

    """


@dataclass
class AttachmentDescriptorV3:
    cdn: Optional[int] = None
    """
    Indicates the CDN type. 2 in the v3 API, 2 or 3 in the v4 API.
    2 indicates resumable uploads using GCS,
    3 indicates resumable uploads using TUS

    """
    key: Optional[str] = None
    """
    The location within the specified cdn where the finished upload can be found
    """
    headers: Optional[Dict[str, str]] = None
    """
    A map of headers to include with all upload requests. Potentially contains time-limited upload credentials
    """
    signedUploadLocation: Optional[str] = None
    """
    The URL to upload to with the appropriate protocol
    """


@dataclass
class CreateCallLinkCredential:
    credential: Optional[str] = None
    redemptionTime: Optional[int] = None


@dataclass
class GetCreateCallLinkCredentialsRequest:
    createCallLinkCredentialRequest: str


@dataclass
class TurnToken:
    username: Optional[str] = None
    password: Optional[str] = None
    urls: Optional[List[str]] = None
    urlsWithIps: Optional[List[str]] = None
    hostname: Optional[str] = None


@dataclass
class GetCallingRelaysResponse:
    relays: Optional[List[TurnToken]] = None


@dataclass
class DeliveryCertificate:
    certificate: Optional[str] = None


@dataclass
class CallLinkAuthCredential:
    credential: Optional[str] = None
    redemptionTime: Optional[int] = None


@dataclass
class GroupCredential:
    credential: Optional[str] = None
    redemptionTime: Optional[int] = None


@dataclass
class GroupCredentials:
    credentials: Optional[List[GroupCredential]] = None
    callLinkAuthCredentials: Optional[List[CallLinkAuthCredential]] = None
    pni: Optional[str] = None


@dataclass
class AnswerChallengeRequest:
    type: str


@dataclass
class ChallengeResponse:
    challenge: Optional[str] = None
    """
    A challenge to use when generating attestations or assertions
    """


class Action(Enum):
    """
    The type of action you'd like to perform with this assert
    """

    backup = "backup"


@dataclass
class AssertionRequest:
    challenge: Optional[str] = None
    """
    The challenge retrieved at `GET /v1/devicecheck/assert`
    """
    action: Optional[Action] = None
    """
    The type of action you'd like to perform with this assert
    """


@dataclass
class LinkDeviceToken:
    tokenIdentifier: Optional[str] = None
    """
    An opaque identifier for the generated token that the caller may use to watch for a new device to complete the
    linking process.

    """
    verificationCode: Optional[str] = None
    """
    An opaque token to send to a new linked device that authorizes the new device to link itself to the account that
    requested this token.

    """


@dataclass
class DeviceInfo:
    id: Optional[int] = None
    name: Optional[str] = None
    lastSeen: Optional[int] = None
    created: Optional[int] = None


@dataclass
class DeviceInfoList:
    devices: Optional[List[DeviceInfo]] = None


@dataclass
class LinkDeviceResponse:
    uuid: Optional[str] = None
    pni: Optional[str] = None
    deviceId: Optional[str] = None


@dataclass
class BasicAuthorizationHeader:
    username: Optional[str] = None
    deviceId: Optional[int] = None
    password: Optional[str] = None


@dataclass
class DeviceActivationRequest:
    aciSignedPreKey: ECSignedPreKey
    pniSignedPreKey: ECSignedPreKey
    aciPqLastResortPreKey: KEMSignedPreKey
    pniPqLastResortPreKey: KEMSignedPreKey
    apnToken: Optional[ApnRegistrationId] = None
    gcmToken: Optional[GcmRegistrationId] = None


@dataclass
class LinkDeviceRequest:
    verificationCode: str
    """
    The verification code associated with this device. Must match the verification code
    provided by the server when provisioning this device.

    """
    aciSignedPreKey: ECSignedPreKey
    pniSignedPreKey: ECSignedPreKey
    aciPqLastResortPreKey: KEMSignedPreKey
    pniPqLastResortPreKey: KEMSignedPreKey
    accountAttributes: Optional[AccountAttributes] = None
    apnToken: Optional[ApnRegistrationId] = None
    gcmToken: Optional[GcmRegistrationId] = None


class Method(Enum):
    """
    The method by which the new device has requested account data restoration
    """

    REMOTE_BACKUP = "REMOTE_BACKUP"
    LOCAL_BACKUP = "LOCAL_BACKUP"
    DEVICE_TRANSFER = "DEVICE_TRANSFER"
    DECLINE = "DECLINE"


@dataclass
class RestoreAccountRequest:
    """
    Represents a request from a new device to restore account data by some method.

    """

    method: Method
    """
    The method by which the new device has requested account data restoration
    """


class Error(Enum):
    """
    The type of error encountered
    """

    RELINK_REQUESTED = "RELINK_REQUESTED"
    CONTINUE_WITHOUT_UPLOAD = "CONTINUE_WITHOUT_UPLOAD"


@dataclass
class RemoteAttachmentError:
    """
    Indicates an attachment failed to upload
    """

    error: Error
    """
    The type of error encountered
    """


TransferArchiveResult = Union[RemoteAttachment, RemoteAttachmentError]


@dataclass
class TransferArchiveUploadedRequest:
    transferArchive: TransferArchiveResult
    destinationDeviceId: Optional[str] = None
    """
    The ID of the device for which the transfer archive has been prepared
    """
    destinationDeviceCreated: Optional[int] = None
    """
    The timestamp, in milliseconds since the epoch, at which the destination device was created
    """


@dataclass
class RedeemReceiptRequest:
    receiptCredentialPresentation: str
    visible: Optional[bool] = None
    primary: Optional[bool] = None


@dataclass
class WebSocketClient:
    created: Optional[str] = None
    userAgent: Optional[str] = None
    open: Optional[bool] = None


@dataclass
class WebSocketSessionContext:
    authenticated: Optional[Dict[str, Any]] = None
    client: Optional[WebSocketClient] = None


@dataclass
class KeyTransparencyDistinguishedKeyResponse:
    serializedResponse: str
    """
    The serialized `DistinguishedResponse` encoded in standard un-padded base64
    """


@dataclass
class KeyTransparencyMonitorResponse:
    serializedResponse: str
    """
    The serialized `MonitorResponse` encoded in standard un-padded base64
    """


@dataclass
class AciMonitor:
    value: str
    """
    An identifier for an account based on the account's ACI
    """
    commitmentIndex: str
    """
    The commitment index derived from a previous search request, encoded in standard unpadded base64
    """
    entryPosition: Optional[int] = None
    """
    A log tree position maintained by the client for the aci.
    """


@dataclass
class E164Monitor:
    value: str
    """
    The e164-formatted phone number to monitor
    """
    commitmentIndex: str
    """
    The commitment index derived from a previous search request, encoded in standard unpadded base64
    """
    entryPosition: Optional[int] = None
    """
    A log tree position maintained by the client for the e164.
    """


@dataclass
class UsernameHashMonitor:
    value: str
    """
    The username hash to monitor, encoded in url-safe unpadded base64.
    """
    commitmentIndex: str
    """
    The commitment index derived from a previous search request, encoded in standard unpadded base64
    """
    entryPosition: Optional[int] = None
    """
    A log tree position maintained by the client for the username hash.
    """


@dataclass
class KeyTransparencySearchResponse:
    serializedResponse: str
    """
    The serialized `SearchResponse` encoded in standard un-padded base64.
    """


@dataclass
class KeyTransparencySearchRequest:
    aci: str
    """
    An identifier for an account based on the account's ACI
    """
    aciIdentityKey: IdentityKey
    e164: Optional[str] = None
    """
    The E164-formatted phone number to look up
    """
    usernameHash: Optional[str] = None
    """
    The username hash to look up, encoded in web-safe unpadded base64.
    """
    unidentifiedAccessKey: Optional[str] = None
    """
    The unidentified access key associated with the account
    """
    lastTreeHeadSize: Optional[int] = None
    """
    The non-distinguished tree head size to prove consistency against.
    """
    distinguishedTreeHeadSize: Optional[int] = None
    """
    The distinguished tree head size to prove consistency against.
    """
    unidentifiedAccessKeyProvidedWithE164: Optional[bool] = None


class IdentityType(Enum):
    """
    The identity type for which to check for a shared view of repeated-use keys

    """

    ACI = "ACI"
    PNI = "PNI"


@dataclass
class CheckKeysRequest:
    identityType: IdentityType
    """
    The identity type for which to check for a shared view of repeated-use keys

    """
    digest: str
    """
    A 32-byte digest of the client's repeated-use keys for the given identity type. The digest is calculated as:

    SHA256(identityKeyBytes || signedEcPreKeyId || signedEcPreKeyIdBytes || lastResortKeyId || lastResortKeyBytes)

    …where the elements of the hash are:

    - identityKeyBytes: the serialized form of the client's public identity key as produced by libsignal (i.e. one
      version byte followed by 32 bytes of key material for a total of 33 bytes)
    - signedEcPreKeyId: an 8-byte, big-endian representation of the ID of the client's signed EC pre-key
    - signedEcPreKeyBytes: the serialized form of the client's signed EC pre-key as produced by libsignal (i.e. one
      version byte followed by 32 bytes of key material for a total of 33 bytes)
    - lastResortKeyId: an 8-byte, big-endian representation of the ID of the client's last-resort Kyber key
    - lastResortKeyBytes: the serialized form of the client's last-resort Kyber key as produced by libsignal (i.e.
      one version byte followed by 1568 bytes of key material for a total of 1569 bytes)

    """


@dataclass
class ECPreKey:
    """
    A list of unsigned elliptic-curve prekeys to use for this device. If present and not empty, replaces all stored
    unsigned EC prekeys for the device; if absent or empty, any stored unsigned EC prekeys for the device are not
    deleted.

    """

    keyId: Optional[int] = None
    """
    An arbitrary ID for this key, which will be provided by peers using this key to encrypt messages so the private key can be looked up.
    Should not be zero. Should be less than 2^24.

    """
    publicKey: Optional[str] = None
    """
    The public key, serialized in libsignal's elliptic-curve public key format and then base64-encoded.

    """


@dataclass
class PreKeyResponseItem:
    """
    information about each requested device
    """

    deviceId: Optional[str] = None
    """
    the device ID of the device to which this item pertains
    """
    registrationId: Optional[int] = None
    """
    the registration ID for the device
    """
    signedPreKey: Optional[ECSignedPreKey] = None
    preKey: Optional[ECPreKey] = None
    pqPreKey: Optional[KEMSignedPreKey] = None


@dataclass
class Anonymous:
    accessKey: Optional[str] = None


@dataclass
class GroupSendFullToken:
    expiration: Optional[str] = None
    internalContentsForJNI: Optional[str] = None


@dataclass
class GroupSendTokenHeader:
    token: Optional[GroupSendFullToken] = None


@dataclass
class PreKeyCount:
    count: Optional[int] = None
    """
    the number of stored unsigned elliptic-curve prekeys for this device
    """
    pqCount: Optional[int] = None
    """
    the number of stored one-time post-quantum prekeys for this device
    """


@dataclass
class SetKeysRequest:
    preKeys: Optional[List[ECPreKey]] = None
    """
    A list of unsigned elliptic-curve prekeys to use for this device. If present and not empty, replaces all stored
    unsigned EC prekeys for the device; if absent or empty, any stored unsigned EC prekeys for the device are not
    deleted.

    """
    signedPreKey: Optional[ECSignedPreKey] = None
    pqPreKeys: Optional[List[KEMSignedPreKey]] = None
    """
    A list of signed post-quantum one-time prekeys to use for this device. Each key must have a valid signature from
    the identity key in this request. If present and not empty, replaces all stored unsigned PQ prekeys for the
    device; if absent or empty, any stored unsigned PQ prekeys for the device are not deleted.

    """
    pqLastResortPreKey: Optional[KEMSignedPreKey] = None


@dataclass
class SpamReport:
    token: Optional[str] = None


@dataclass
class IncomingMessageList:
    messages: List[IncomingMessage]
    online: Optional[bool] = None
    urgent: Optional[bool] = None
    timestamp: Optional[int] = None


@dataclass
class AccountMismatchedDevices:
    uuid: Optional[str] = None
    """
    A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
    """
    devices: Optional[MismatchedDevices] = None


@dataclass
class AccountStaleDevices:
    uuid: Optional[str] = None
    """
    A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
    """
    devices: Optional[StaleDevices] = None


@dataclass
class CombinedUnidentifiedSenderAccessKeys:
    accessKeys: Optional[str] = None


@dataclass
class DevicesAndRegistrationIds:
    parallel: Optional[bool] = None


@dataclass
class Recipient:
    devices: Optional[str] = None
    devicesAndRegistrationIds: Optional[DevicesAndRegistrationIds] = None


@dataclass
class ServiceId:
    rawUUID: Optional[str] = None


class PaymentMethod(Enum):
    """
    The payment method
    """

    UNKNOWN = "UNKNOWN"
    CARD = "CARD"
    PAYPAL = "PAYPAL"
    SEPA_DEBIT = "SEPA_DEBIT"
    IDEAL = "IDEAL"
    GOOGLE_PLAY_BILLING = "GOOGLE_PLAY_BILLING"
    APPLE_APP_STORE = "APPLE_APP_STORE"


@dataclass
class ConfirmPayPalBoostRequest:
    currency: str
    amount: int
    """
    The amount to pay in the [currency's minor unit](https://docs.stripe.com/currencies#minor-units)
    """
    payerId: str
    paymentId: str
    paymentToken: str
    level: Optional[int] = None
    """
    The level for the boost payment. Assumed to be the boost level if missing
    """
    paymentMethod: Optional[PaymentMethod] = PaymentMethod.CARD
    """
    The payment method
    """


@dataclass
class CreateBoostResponse:
    clientSecret: Optional[str] = None
    """
    A client secret that can be used to complete a stripe PaymentIntent
    """


@dataclass
class CreateBoostRequest:
    currency: str
    amount: int
    """
    The amount to pay in the [currency's minor unit](https://docs.stripe.com/currencies#minor-units)
    """
    level: Optional[int] = None
    """
    The level for the boost payment. Assumed to be the boost level if missing
    """
    paymentMethod: Optional[PaymentMethod] = PaymentMethod.CARD
    """
    The payment method
    """


class Processor(Enum):
    STRIPE = "STRIPE"
    BRAINTREE = "BRAINTREE"
    GOOGLE_PLAY_BILLING = "GOOGLE_PLAY_BILLING"
    APPLE_APP_STORE = "APPLE_APP_STORE"


@dataclass
class CreateBoostReceiptCredentialsRequest:
    paymentIntentId: str
    receiptCredentialRequest: str
    processor: Processor


@dataclass
class CreatePayPalBoostRequest:
    currency: str
    amount: int
    """
    The amount to pay in the [currency's minor unit](https://docs.stripe.com/currencies#minor-units)
    """
    returnUrl: str
    cancelUrl: str
    level: Optional[int] = None
    """
    The level for the boost payment. Assumed to be the boost level if missing
    """
    paymentMethod: Optional[PaymentMethod] = PaymentMethod.CARD
    """
    The payment method
    """


@dataclass
class CurrencyConversionEntity:
    base: Optional[str] = None
    conversions: Optional[Dict[str, float]] = None


@dataclass
class CurrencyConversionEntityList:
    currencies: Optional[List[CurrencyConversionEntity]] = None
    timestamp: Optional[int] = None


@dataclass
class BadgeSvg:
    light: str
    dark: str


@dataclass
class Element:
    uuid: str
    """
    A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
    """
    fingerprint: str


@dataclass
class BatchIdentityCheckRequest:
    elements: List[Element]


class AvatarChange(Enum):
    UNCHANGED = "UNCHANGED"
    CLEAR = "CLEAR"
    UPDATE = "UPDATE"


@dataclass
class ProfileKeyCommitment:
    internalContentsForJNI: Optional[str] = None


@dataclass
class ProvisioningMessage:
    body: str
    """
    The MIME base64-encoded body of the provisioning message to send to the destination device
    """


@dataclass
class RegistrationRequest:
    accountAttributes: AccountAttributes
    skipDeviceTransfer: bool
    """
    If true, indicates that the end user has elected not to transfer data from another
    device even though a device transfer is technically possible given the capabilities of
    the calling device and the device associated with the existing account (if any). If
    false and if a device transfer is technically possible, the registration request will
    fail with an HTTP/409 response indicating that the client should prompt the user to
    transfer data from an existing device.

    """
    aciIdentityKey: IdentityKey
    pniIdentityKey: IdentityKey
    aciSignedPreKey: ECSignedPreKey
    pniSignedPreKey: ECSignedPreKey
    aciPqLastResortPreKey: KEMSignedPreKey
    pniPqLastResortPreKey: KEMSignedPreKey
    sessionId: Optional[str] = None
    """
    The ID of an existing verification session as it appears in a verification session
    metadata object. Must be provided if `recoveryPassword` is not provided; must not be
    provided if `recoveryPassword` is provided.

    """
    recoveryPassword: Optional[str] = None
    """
    A base64-encoded registration recovery password. Must be provided if `sessionId` is
    not provided; must not be provided if `sessionId` is provided

    """
    apnToken: Optional[ApnRegistrationId] = None
    gcmToken: Optional[GcmRegistrationId] = None
    valid: Optional[bool] = None


@dataclass
class UserRemoteConfig:
    """
    List of remote configurations applicable to the user
    """

    name: Optional[str] = None
    """
    Name of the configuration
    """
    enabled: Optional[bool] = None
    """
    Whether the configuration is enabled for the user
    """
    value: Optional[str] = None
    """
    The value to be used for the configuration, if it is a non-boolean type
    """


@dataclass
class UserRemoteConfigList:
    config: Optional[List[UserRemoteConfig]] = None
    """
    List of remote configurations applicable to the user
    """
    serverEpochTime: Optional[str] = None
    """
    Timestamp when the configuration was generated. Deprecated in favor of `X-Signal-Timestamp` response header.

    """


class Matches(Enum):
    """
    A dictionary with the auth check results: `SVR Credentials -> 'match'/'no-match'/'invalid'`
    """

    match = "match"
    no_match = "no-match"
    invalid = "invalid"


@dataclass
class AuthCheckResponseV2:
    matches: Dict[str, Matches]
    """
    A dictionary with the auth check results: `SVR Credentials -> 'match'/'no-match'/'invalid'`
    """


@dataclass
class AuthCheckRequest:
    number: str
    """
    The e164-formatted phone number.
    """
    tokens: List[str]
    """
    A list of SVR tokens, previously retrieved from `backup/auth`. Tokens should be the
    of the form "username:password". May contain at most 10 tokens.
    """


@dataclass
class StickerPackFormUploadItem:
    id: Optional[int] = None
    key: Optional[str] = None
    credential: Optional[str] = None
    acl: Optional[str] = None
    algorithm: Optional[str] = None
    date: Optional[str] = None
    policy: Optional[str] = None
    signature: Optional[str] = None


@dataclass
class CreatePayPalBillingAgreementRequest:
    returnUrl: str
    cancelUrl: str


@dataclass
class GetReceiptCredentialsRequest:
    receiptCredentialRequest: str


@dataclass
class BackupLevelConfiguration:
    """
    Configuration for a backup level - use to present appropriate client interfaces
    """

    storageAllowanceBytes: Optional[int] = None
    """
    The amount of media storage in bytes that a paying subscriber may store
    """
    playProductId: Optional[str] = None
    """
    The play billing productID associated with this backup level
    """
    mediaTtlDays: Optional[int] = None
    """
    The duration, in days, for which your backed up media is retained on the server after you stop refreshing with a paid credential
    """


@dataclass
class CurrencyConfiguration:
    """
    Configuration for a currency - use to present appropriate client interfaces
    """

    minimum: Optional[float] = None
    """
    The minimum amount that may be submitted for a one-time donation in the currency
    """
    oneTime: Optional[Dict[str, List[float]]] = None
    """
    A map of numeric one-time donation level IDs to the list of default amounts to be presented
    """
    subscription: Optional[Dict[str, float]] = None
    """
    A map of numeric subscription level IDs to the amount charged for that level
    """
    backupSubscription: Optional[Dict[str, float]] = None
    """
    A map of numeric backup level IDs to the amount charged for that level
    """
    supportedPaymentMethods: Optional[List[str]] = None
    """
    The payment methods that support the given currency
    """


@dataclass
class ChargeFailure:
    """
    Meaningfully interpreting chargeFailure response fields requires inspecting the processor field first.

    For Stripe, code will be one of the [codes defined here](https://stripe.com/docs/api/charges/object#charge_object-failure_code),
    while message [may contain a further textual description](https://stripe.com/docs/api/charges/object#charge_object-failure_message).
    The outcome fields are nullable, but present values will directly map to Stripe [response properties](https://stripe.com/docs/api/charges/object#charge_object-outcome-network_status)

    For Braintree, the outcome fields will be null. The code and message will contain one of
      - a processor decline code (as a string) in code, and associated text in message, as defined this [table](https://developer.paypal.com/braintree/docs/reference/general/processor-responses/authorization-responses)
      - `gateway` in code, with a [reason](https://developer.paypal.com/braintree/articles/control-panel/transactions/gateway-rejections) in message
      - `code` = "unknown", message = "unknown"

    IAP payment processors will never include charge failure information, and detailed order information should be
    retrieved from the payment processor directly

    """

    code: Optional[str] = None
    """
    See [Stripe failure codes](https://stripe.com/docs/api/charges/object#charge_object-failure_code) or
    [Braintree decline codes](https://developer.paypal.com/braintree/docs/reference/general/processor-responses/authorization-responses#decline-codes)
    depending on which processor was used

    """
    message: Optional[str] = None
    """
    See [Stripe failure codes](https://stripe.com/docs/api/charges/object#charge_object-failure_code) or
    [Braintree decline codes](https://developer.paypal.com/braintree/docs/reference/general/processor-responses/authorization-responses#decline-codes)
    depending on which processor was used

    """
    outcomeNetworkStatus: Optional[str] = None
    outcomeReason: Optional[str] = None
    outcomeType: Optional[str] = None


class Processor1(Enum):
    """
    The payment provider associated with the subscription
    """

    STRIPE = "STRIPE"
    BRAINTREE = "BRAINTREE"
    GOOGLE_PLAY_BILLING = "GOOGLE_PLAY_BILLING"
    APPLE_APP_STORE = "APPLE_APP_STORE"


class PaymentMethod3(Enum):
    """
    The payment method associated with the subscription
    """

    UNKNOWN = "UNKNOWN"
    CARD = "CARD"
    PAYPAL = "PAYPAL"
    SEPA_DEBIT = "SEPA_DEBIT"
    IDEAL = "IDEAL"
    GOOGLE_PLAY_BILLING = "GOOGLE_PLAY_BILLING"
    APPLE_APP_STORE = "APPLE_APP_STORE"


@dataclass
class Subscription:
    """
    Information about the subscription, or null if no subscription is present
    """

    level: Optional[int] = None
    """
    The subscription level
    """
    billingCycleAnchor: Optional[str] = None
    """
    If present, UNIX Epoch Timestamp in seconds, can be used to calculate next billing date.
    """
    endOfCurrentPeriod: Optional[str] = None
    """
    UNIX Epoch Timestamp in seconds, when the current subscription period ends
    """
    active: Optional[bool] = None
    """
    Whether there is a currently active subscription
    """
    cancelAtPeriodEnd: Optional[bool] = None
    """
    If true, an active subscription will not auto-renew at the end of the current period
    """
    currency: Optional[str] = None
    """
    A three-letter ISO 4217 currency code for currency used in the subscription
    """
    amount: Optional[float] = None
    """
    The amount paid for the subscription in the currency's smallest unit
    """
    status: Optional[str] = None
    """
    The subscription's status, mapped to Stripe's statuses. trialing will never be returned
    """
    processor: Optional[Processor1] = None
    """
    The payment provider associated with the subscription
    """
    paymentMethod: Optional[PaymentMethod3] = None
    """
    The payment method associated with the subscription
    """
    paymentProcessing: Optional[bool] = None
    """
    Whether the latest invoice for the subscription is in a non-terminal state
    """


class RequestedInformation(Enum):
    """
    A list of requested information that the client needs to submit before requesting code delivery
    """

    pushChallenge = "pushChallenge"
    captcha = "captcha"


@dataclass
class VerificationSessionResponse:
    id: str
    """
    A URL-safe ID for the session
    """
    allowedToRequestCode: bool
    """
    Whether it is allowed to request a verification code for this session
    """
    verified: bool
    """
    Whether this session is verified
    """
    nextSms: Optional[int] = None
    """
    Duration in seconds after which next SMS can be requested for this session
    """
    nextCall: Optional[int] = None
    """
    Duration in seconds after which next voice call can be requested for this session
    """
    nextVerificationAttempt: Optional[int] = None
    """
    Duration in seconds after which the client can submit a verification code for this session
    """
    requestedInformation: Optional[List[RequestedInformation]] = None
    """
    A list of requested information that the client needs to submit before requesting code delivery
    """


class PushTokenType(Enum):
    """
    The type of push token
    """

    apn = "apn"
    fcm = "fcm"


@dataclass
class CreateVerificationSessionRequest:
    number: str
    """
    The e164-formatted phone number to be verified
    """
    pushToken: Optional[str] = None
    """
    The APNs or FCM device token to which a push challenge can be sent
    """
    pushTokenType: Optional[PushTokenType] = None
    """
    The type of push token
    """
    pushChallenge: Optional[str] = None
    """
    Value received by the device in the push challenge
    """
    captcha: Optional[str] = None
    """
    Captcha token returned after solving a captcha challenge
    """
    mcc: Optional[str] = None
    """
    Mobile country code of the phone subscriber
    """
    mnc: Optional[str] = None
    """
    Mobile network code of the phone subscriber
    """


@dataclass
class UpdateVerificationSessionRequest:
    pushToken: Optional[str] = None
    """
    The APNs or FCM device token to which a push challenge can be sent
    """
    pushTokenType: Optional[PushTokenType] = None
    """
    The type of push token
    """
    pushChallenge: Optional[str] = None
    """
    Value received by the device in the push challenge
    """
    captcha: Optional[str] = None
    """
    Captcha token returned after solving a captcha challenge
    """
    mcc: Optional[str] = None
    """
    Mobile country code of the phone subscriber
    """
    mnc: Optional[str] = None
    """
    Mobile network code of the phone subscriber
    """


class Reason(Enum):
    providerUnavailable = "providerUnavailable"
    providerRejected = "providerRejected"
    illegalArgument = "illegalArgument"


@dataclass
class SendVerificationCodeFailureResponse:
    reason: Optional[Reason] = None
    permanentFailure: Optional[bool] = None


class Transport(Enum):
    """
    Transport via which to send the verification code
    """

    sms = "sms"
    voice = "voice"


@dataclass
class VerificationCodeRequest:
    transport: Transport
    """
    Transport via which to send the verification code
    """
    client: str
    """
    Client type to facilitate platform-specific SMS verification
    """


@dataclass
class SubmitVerificationCodeRequest:
    code: str


@dataclass
class AciServiceIdentifier(ServiceIdentifier):
    """
    An identifier for an account based on the account's ACI
    """


@dataclass
class PniServiceIdentifier(ServiceIdentifier):
    """
    An identifier for an account based on the account's phone number identifier (PNI)
    """


@dataclass
class AccountIdentityResponse:
    uuid: Optional[str] = None
    """
    the account identifier for this account
    """
    number: Optional[str] = None
    """
    the phone number associated with this account
    """
    pni: Optional[str] = None
    """
    the account identifier for this account's phone-number identity
    """
    usernameHash: Optional[str] = None
    """
    a hash of this account's username, if set
    """
    usernameLinkHandle: Optional[str] = None
    """
    this account's username link handle, if set
    """
    storageCapable: Optional[bool] = None
    """
    whether any of this account's devices support storage
    """
    entitlements: Optional[Entitlements] = None


@dataclass
class ChangeNumberRequest:
    number: str
    """
    the new phone number for this account
    """
    pniIdentityKey: IdentityKey
    deviceMessages: List[IncomingMessage]
    """
    A list of synchronization messages to send to companion devices to supply the private keysManager
    associated with the new identity key and their new prekeys.
    Exactly one message must be supplied for each enabled device other than the sending (primary) device.
    """
    devicePniSignedPrekeys: Dict[str, ECSignedPreKey]
    """
    A new signed elliptic-curve prekey for each enabled device on the account, including this one.
    Each must be accompanied by a valid signature from the new identity key in this request.
    """
    pniRegistrationIds: Dict[str, int]
    """
    the new phone-number-identity registration ID for each enabled device on the account, including this one
    """
    sessionId: Optional[str] = None
    """
    A session ID from registration service, if using session id to authenticate this request.
    Must not be combined with `recoveryPassword`.
    """
    recoveryPassword: Optional[str] = None
    """
    The base64-encoded recovery password for the new phone number, if using a recovery password to authenticate this request.
    Must not be combined with `sessionId`.
    """
    devicePniPqLastResortPrekeys: Optional[Dict[str, KEMSignedPreKey]] = None
    """
    A new signed post-quantum last-resort prekey for each enabled device on the account, including this one.
    May be absent, in which case the last resort PQ prekeys for each device will be deleted if any had been stored.
    If present, must contain one prekey per enabled device including this one.
    Prekeys for devices that did not previously have any post-quantum prekeys stored will be silently dropped.
    Each must be accompanied by a valid signature from the new identity key in this request.
    """
    eachPniRegistrationIdValid: Optional[bool] = None
    valid: Optional[bool] = None
    reglock: Optional[str] = None
    """
    the registration lock password for the new phone number, if necessary
    """


@dataclass
class AccountDataReport:
    phoneNumber: Optional[str] = None
    badges: Optional[List[BadgeDataReport]] = None
    allowSealedSenderFromAnyone: Optional[bool] = None
    findAccountByPhoneNumber: Optional[bool] = None


@dataclass
class CopyMediaBatchResponse:
    responses: Optional[List[Entry]] = None
    """
    Detailed outcome information for each copy request in the batch
    """


@dataclass
class CopyMediaRequest:
    sourceAttachment: RemoteAttachment
    objectLength: int
    """
    The length of the source attachment before the encryption applied by the copy operation
    """
    mediaId: str
    """
    mediaId to copy on to the backup CDN, encoded in URL-safe padded base64
    """
    hmacKey: str
    """
    A 32-byte key for the MAC, encoded in standard padded base64
    """
    encryptionKey: str
    """
    A 32-byte encryption key for AES, encoded in standard padded base64
    """


@dataclass
class DeleteMedia:
    mediaToDelete: Optional[List[MediaToDelete]] = None


@dataclass
class ListResponse:
    storedMediaObjects: Optional[List[StoredMediaObject]] = None
    """
    A page of media objects stored for this backup ID
    """
    backupDir: Optional[str] = None
    """
    The base directory of your backup data on the cdn. The stored media can be found at /backupDir/mediaDir/mediaId

    """
    mediaDir: Optional[str] = None
    """
    The prefix path component for the media objects. The stored media for mediaId can be found at /backupDir/mediaDir/mediaId.

    """
    cursor: Optional[str] = None
    """
    If set, the cursor value to pass to the next list request to continue listing. If absent, all objects have been listed
    """


@dataclass
class AnswerPushChallengeRequest(AnswerChallengeRequest):
    challenge: str
    """
    A token provided to the client via a push payload
    """


@dataclass
class AnswerCaptchaChallengeRequest(AnswerChallengeRequest):
    token: str
    """
    The value of the token field from the server's 428 response
    """
    captcha: str
    """
    A string representing a solved captcha
    """


@dataclass
class KeyTransparencyMonitorRequest:
    aci: AciMonitor
    e164: E164Monitor
    usernameHash: UsernameHashMonitor
    lastNonDistinguishedTreeHeadSize: Optional[int] = None
    """
    The tree head size to prove consistency against.
    """
    lastDistinguishedTreeHeadSize: Optional[int] = None
    """
    The distinguished tree head size to prove consistency against.
    """


@dataclass
class PreKeyResponse:
    identityKey: Optional[IdentityKey] = None
    devices: Optional[List[PreKeyResponseItem]] = None
    """
    information about each requested device
    """


@dataclass
class SealedSenderMultiRecipientMessage:
    recipients: Optional[Dict[str, Recipient]] = None
    excludedRecipients: Optional[List[ServiceId]] = None


@dataclass
class Badge:
    """
    The displayable badge associated with the level
    """

    id: Optional[str] = None
    category: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    sprites6: Optional[List[str]] = None
    svg: Optional[str] = None
    svgs: Optional[List[BadgeSvg]] = None
    imageUrl: Optional[str] = None


@dataclass
class BaseProfileResponse:
    identityKey: Optional[IdentityKey] = None
    unidentifiedAccess: Optional[str] = None
    unrestrictedUnidentifiedAccess: Optional[bool] = None
    capabilities: Optional[Dict[str, bool]] = None
    badges: Optional[List[Badge]] = None
    uuid: Optional[str] = None
    """
    A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
    """


@dataclass
class VersionedProfileResponse:
    identityKey: Optional[IdentityKey] = None
    unidentifiedAccess: Optional[str] = None
    unrestrictedUnidentifiedAccess: Optional[bool] = None
    capabilities: Optional[Dict[str, bool]] = None
    badges: Optional[List[Badge]] = None
    uuid: Optional[str] = None
    """
    A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
    """
    name: Optional[str] = None
    about: Optional[str] = None
    aboutEmoji: Optional[str] = None
    avatar: Optional[str] = None
    paymentAddress: Optional[str] = None
    phoneNumberSharing: Optional[str] = None


@dataclass
class CredentialProfileResponse:
    identityKey: Optional[IdentityKey] = None
    unidentifiedAccess: Optional[str] = None
    unrestrictedUnidentifiedAccess: Optional[bool] = None
    capabilities: Optional[Dict[str, bool]] = None
    badges: Optional[List[Badge]] = None
    uuid: Optional[str] = None
    """
    A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
    """
    name: Optional[str] = None
    about: Optional[str] = None
    aboutEmoji: Optional[str] = None
    avatar: Optional[str] = None
    paymentAddress: Optional[str] = None
    phoneNumberSharing: Optional[str] = None


@dataclass
class BatchIdentityCheckResponse:
    elements: Optional[List[Element]] = None


@dataclass
class CreateProfileRequest:
    commitment: ProfileKeyCommitment
    version: str
    name: Optional[str] = None
    aboutEmoji: Optional[str] = None
    about: Optional[str] = None
    paymentAddress: Optional[str] = None
    sameAvatar: Optional[bool] = None
    phoneNumberSharing: Optional[str] = None
    avatarChange: Optional[AvatarChange] = None
    avatar: Optional[bool] = None
    badgeIds: Optional[List[str]] = None


@dataclass
class StickerPackFormUploadAttributes:
    manifest: Optional[StickerPackFormUploadItem] = None
    stickers: Optional[List[StickerPackFormUploadItem]] = None
    packId: Optional[str] = None


@dataclass
class BackupConfiguration:
    """
    Backup specific configuration
    """

    levels: Optional[Dict[str, BackupLevelConfiguration]] = None
    """
    A map of numeric backup level IDs to level-specific backup configuration
    """
    freeTierMediaDays: Optional[int] = None
    """
    The number of days of media a free tier backup user gets
    """


@dataclass
class LevelConfiguration:
    """
    Configuration for a donation level - use to present appropriate client interfaces
    """

    name: Optional[str] = None
    """
    The localized name for the level
    """
    badge: Optional[Badge] = None


@dataclass
class GetSubscriptionInformationResponse:
    subscription: Optional[Subscription] = None
    chargeFailure: Optional[ChargeFailure] = None


@dataclass
class AccountAndDevicesDataReport:
    account: Optional[AccountDataReport] = None
    devices: Optional[List[DeviceDataReport]] = None


@dataclass
class AccountDataReportResponse:
    reportId: Optional[str] = None
    reportTimestamp: Optional[str] = None
    data: Optional[AccountAndDevicesDataReport] = None
    text: Optional[str] = None
    """
    A plaintext representation of the data report
    """


@dataclass
class CopyMediaBatchRequest:
    items: List[CopyMediaRequest]
    """
    A list of media objects to copy from the attachments CDN to the backup CDN
    """


@dataclass
class GetSubscriptionConfigurationResponse:
    """
    Comprehensive configuration for donation subscriptions, backup subscriptions, gift subscriptions, and one-time
    donations pricing information for all levels are included in currencies. All levels that have an associated
    badge are included in levels.  All levels that correspond to a backup payment tier are included in
    backupLevels.
    """

    currencies: Optional[Dict[str, CurrencyConfiguration]] = None
    """
    A map of lower-cased ISO 3 currency codes to minimums and level-specific scalar amounts
    """
    levels: Optional[Dict[str, LevelConfiguration]] = None
    """
    A map of numeric donation level IDs to level-specific badge configuration
    """
    backup: Optional[BackupConfiguration] = None
    sepaMaximumEuros: Optional[float] = None
    """
    The maximum value of a one-time donation SEPA transaction
    """
